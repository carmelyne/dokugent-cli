import path from 'path';
import fs from 'fs/promises';
import { AGENT_DIR } from '../../constants/paths';
import minimist from 'minimist';
import { walkPlan, PlanStep } from '@utils/dryrun/walk-plan';
import { ui, paddedLog, paddedSub, printTable, menuList, padMsg, PAD_WIDTH, paddedCompact, glyphs, paddedDefault, padQuestion, paddedLongText, phaseHeader, phaseHeaderCompact, narrateDryrunStep } from '@utils/cli/ui';
import { wrapWithHangingIndent } from '@utils/cli/wrap-utils';
import chalk from 'chalk';
import { slowPrint } from '@utils/cli/slowPrint';

export async function runDryrunCommand(argv: string[] = []) {
  const args = minimist(argv);
  const summaryOnly = args.summary || false;

  paddedLog('dokugent dryrun initialized...', '', PAD_WIDTH, 'info');
  // Load current agent from symlink
  const currentAgentPath = path.join(AGENT_DIR, 'current', 'identity.json');
  let currentAgentId = '';

  try {
    const identity = JSON.parse(await fs.readFile(currentAgentPath, 'utf-8'));
    // Always compute the agentId from agentName and birth fields
    currentAgentId = `${identity.agentName}@${identity.birth}`;
  } catch {
    console.error('❌ Failed to load current agent identity. Make sure the symlink exists.');
    return;
  }

  // Derive compiled path based on current agent ID
  const compiledPath = path.join('.dokugent/ops/compiled', currentAgentId);
  const files = await fs.readdir(compiledPath);
  const compiledFiles = files
    .filter(f => /\.compiled\.v\d+\.cert\.json$/.test(f))
    .sort((a, b) => {
      const getVersion = (name: string) => {
        const match = name.match(/\.v(\d+)\.cert\.json$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getVersion(b) - getVersion(a); // Descending order
    });

  if (compiledFiles.length === 0) {
    console.error(`❌ No compiled certs found for agent ${currentAgentId}.`);
    return;
  }

  // Load the latest compiled certificate file for the agent
  const latestCertFile = compiledFiles[0];
  const certPath = path.join(compiledPath, latestCertFile);
  const certData = JSON.parse(await fs.readFile(certPath, 'utf-8'));
  paddedLog('Loaded certificate...', latestCertFile, PAD_WIDTH, 'magenta', 'CERT');

  // paddedLog('agent', currentAgentId, PAD_WIDTH, 'info', '🧠');
  const birthTime = certData?.agent?.birth || (certData?.agent?.agentName?.match(/@(.+)$/) || [])[1] || 'unknown';
  // paddedLog('birth', birthTime, PAD_WIDTH, 'info', '📅');

  // Extract plan steps from the certificate data
  const steps = certData?.plan?.steps;
  if (!steps || steps.length === 0) {
    console.error('❌ No steps found in the compiled cert.');
    return;
  }

  // If summary flag is set, print summary of steps and exit
  if (summaryOnly) {
    console.log(`📋 Summary of planned steps for agent '${currentAgentId}':\n`);
    steps.forEach((step: any) => {
      console.log(`• ${step.id} → Tool: ${step.use}`);
      // phaseHeaderCompact('1', 'Agent Identity Verification');
    });
    return;
  }

  // Holds simulated memory of output file content to track dependencies across steps
  const memory: Record<string, string> = {};

  // Iterate through each step to simulate execution without actual file writes
  for (const step of steps) {
    narrateDryrunStep(step.id, step.use, step.input, step.output, step.goal, step.constraints);

    // Warn if input was never generated by a previous step
    if (!memory[step.input]) {
      paddedLog(`No prior step produced '${step.input}'.`, 'Will attempt to read from disk or mocks.', 12, 'warn', 'WARN');
      console.log();
      // phaseHeaderCompact('output', step.output, '#FFA500');
    }

    // Warn if output will overwrite a previous file
    if (memory[step.output]) {
      paddedLog(`Output '${step.output}' is already in memory. Overwriting.`, '', PAD_WIDTH, 'warn', 'WARN');
    }

    // Simulate reading input file (this would be used by the agent in a real run)
    try {
      const inputPath = path.resolve(AGENT_DIR, step.input);
      await fs.readFile(inputPath, 'utf-8');
      paddedLog('input file', `'${step.input}' simulated successfully.`, PAD_WIDTH, 'success', 'SUCCESS');
    } catch {
      const mockPath = path.join('.dokugent/ops/mocks', step.input);
      try {
        await fs.readFile(mockPath, 'utf-8');
        console.log();
        paddedDefault('Loaded mock for', `'${step.input}' found in mocks directory.`, PAD_WIDTH, 'pink', 'FALLBACK');
        console.log();
      } catch {
        paddedLog(`Input file '${step.input}' not found. Proceeding with mock.`, '', PAD_WIDTH, 'warn', 'WARN');
      }
    }

    memory[step.output] = `[simulated output for ${step.id}]`;
    paddedDefault('Pretending to write', `Mock generated for '${step.output}'`, PAD_WIDTH, 'pink', 'MOCK OUTPUT');
  }

  // Output mock memory content and confirm simulation is complete
  // phaseHeaderCompact('memory', 'Final simulated output map');
  Object.entries(memory).forEach(([k, v]) => {
    console.log();
    paddedDefault('', `• ${k} → ${v}`, PAD_WIDTH, 'pink', 'MEMORY MAP');
  });

  // Output mock memory content and confirm simulation is complete
  console.log();
  paddedDefault('status', 'Dryrun complete. No changes were made.', PAD_WIDTH, 'success', 'STATUS');
  console.log();
  paddedLog('To simulate agent behavior using this plan', `dokugent simulate`, PAD_WIDTH, 'blue', 'HELP');
  console.log();
}
