import path from 'path';
import fs from 'fs/promises';
import { AGENT_DIR } from '@constants/paths';
import minimist from 'minimist';
import { walkPlan, PlanStep } from '@utils/dryrun/walk-plan';

export async function runDryrunCommand(argv: string[] = []) {
  const args = minimist(argv);
  const summaryOnly = args.summary || false;

  console.log('\nðŸ§ª Dryrun task initialized. No execution will occur.\n');

  // Locate compiled agents directory and read agents
  const compiledDir = path.join('.dokugent/ops/compiled');
  let agents = await fs.readdir(compiledDir);
  agents = agents.filter(name => !name.startsWith('.')); // Skip system files like .DS_Store
  if (agents.length === 0) {
    console.error('âŒ No compiled agents found.');
    return;
  }

  // Select the first agent found for dryrun
  const agent = agents[0]; // For now, use the first agent found
  const agentPath = path.join(compiledDir, agent);
  const files = await fs.readdir(agentPath);
  const compiledFiles = files
    .filter(f => /\.compiled\.v\d+\.cert\.json$/.test(f))
    .sort((a, b) => {
      const getVersion = (name: string) => {
        const match = name.match(/\.v(\d+)\.cert\.json$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getVersion(b) - getVersion(a); // Descending order
    });
  if (compiledFiles.length === 0) {
    console.error(`âŒ No compiled certs found for agent ${agent}.`);
    return;
  }

  // Load the latest compiled certificate file for the agent
  const latestCertFile = compiledFiles[0];
  const certPath = path.join(agentPath, latestCertFile);
  const certData = JSON.parse(await fs.readFile(certPath, 'utf-8'));
  console.log(`ðŸ“„ Certificate file used: ${latestCertFile}`);

  console.log(`ðŸ§  Running dryrun for agent: ${agent}`);
  const birthTime = certData?.agent?.birth || (certData?.agent?.agentName?.match(/@(.+)$/) || [])[1] || 'unknown';
  console.log(`ðŸ“… Certificate generated at: ${birthTime}\n`);

  // Extract plan steps from the certificate data
  const steps = certData?.plan?.steps;
  if (!steps || steps.length === 0) {
    console.error('âŒ No steps found in the compiled cert.');
    return;
  }

  // If summary flag is set, print summary of steps and exit
  if (summaryOnly) {
    console.log(`ðŸ“‹ Summary of planned steps for agent '${agent}':\n`);
    steps.forEach((step: any) => {
      console.log(`â€¢ ${step.id} â†’ Tool: ${step.use}`);
    });
    return;
  }

  // Holds simulated memory of output file content to track dependencies across steps
  const memory: Record<string, string> = {};

  // Iterate through each step to simulate execution without actual file writes
  for (const step of steps) {
    console.log(`ðŸ§© Step: ${step.id}`);
    console.log(`ðŸ”§ Tool: ${step.use}`);
    console.log(`ðŸ“¥ Input: ${step.input}`);
    console.log(`ðŸ“¤ Output: ${step.output}`);
    if (step.goal) console.log(`ðŸŽ¯ Goal: ${step.goal}`);
    if (step.constraints) console.log(`ðŸš§ Constraints: ${step.constraints.join(', ')}`);

    // Warn if input was never generated by a previous step
    if (!memory[step.input]) {
      console.warn(`ðŸš¨ Input '${step.input}' has not been generated by any prior step.`);
    }

    // Warn if output will overwrite a previous file
    if (memory[step.output]) {
      console.warn(`âš ï¸ Output '${step.output}' is already in memory. Overwriting.`);
    }

    // Simulate reading input file (this would be used by the agent in a real run)
    try {
      const inputPath = path.resolve(AGENT_DIR, step.input);
      await fs.readFile(inputPath, 'utf-8');
      console.log(`ðŸ“„ Input file '${step.input}' simulated successfully.`);
    } catch {
      console.warn(`âš ï¸ Input file '${step.input}' not found. Proceeding with mock.`);
    }

    memory[step.output] = `[simulated output for ${step.id}]`;
    console.log(`ðŸ§  Mock output generated for: ${step.output}\n`);
  }

  // Output mock memory content and confirm simulation is complete
  console.log('ðŸ“¦ Simulated memory contents:');
  Object.entries(memory).forEach(([k, v]) => {
    console.log(`   â€¢ ${k} â†’ ${v}`);
  });

  // Output mock memory content and confirm simulation is complete
  console.log('\nâœ… Dryrun complete. No files were written or executed.\n');
}
