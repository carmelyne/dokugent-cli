import path from 'path';
import fs from 'fs/promises';
import { AGENT_DIR } from '@constants/paths';
import minimist from 'minimist';
import { walkPlan, PlanStep } from '@utils/dryrun/walk-plan';

export async function runDryrunCommand(argv: string[] = []) {
  const args = minimist(argv);
  const summaryOnly = args.summary || false;

  console.log('\n🧪 Dryrun task initialized. No execution will occur.\n');

  // Locate compiled agents directory and read agents
  const compiledDir = path.join('.dokugent/ops/compiled');
  let agents = await fs.readdir(compiledDir);
  agents = agents.filter(name => !name.startsWith('.')); // Skip system files like .DS_Store
  if (agents.length === 0) {
    console.error('❌ No compiled agents found.');
    return;
  }

  // Select the first agent found for dryrun
  const agent = agents[0]; // For now, use the first agent found
  const agentPath = path.join(compiledDir, agent);
  const files = await fs.readdir(agentPath);
  const compiledFiles = files
    .filter(f => /\.compiled\.v\d+\.cert\.json$/.test(f))
    .sort((a, b) => {
      const getVersion = (name: string) => {
        const match = name.match(/\.v(\d+)\.cert\.json$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getVersion(b) - getVersion(a); // Descending order
    });
  if (compiledFiles.length === 0) {
    console.error(`❌ No compiled certs found for agent ${agent}.`);
    return;
  }

  // Load the latest compiled certificate file for the agent
  const latestCertFile = compiledFiles[0];
  const certPath = path.join(agentPath, latestCertFile);
  const certData = JSON.parse(await fs.readFile(certPath, 'utf-8'));
  console.log(`📄 Certificate file used: ${latestCertFile}`);

  console.log(`🧠 Running dryrun for agent: ${agent}`);
  const birthTime = certData?.agent?.birth || (certData?.agent?.agentName?.match(/@(.+)$/) || [])[1] || 'unknown';
  console.log(`📅 Certificate generated at: ${birthTime}\n`);

  // Extract plan steps from the certificate data
  const steps = certData?.plan?.steps;
  if (!steps || steps.length === 0) {
    console.error('❌ No steps found in the compiled cert.');
    return;
  }

  // If summary flag is set, print summary of steps and exit
  if (summaryOnly) {
    console.log(`📋 Summary of planned steps for agent '${agent}':\n`);
    steps.forEach((step: any) => {
      console.log(`• ${step.id} → Tool: ${step.use}`);
    });
    return;
  }

  // Holds simulated memory of output file content to track dependencies across steps
  const memory: Record<string, string> = {};

  // Iterate through each step to simulate execution without actual file writes
  for (const step of steps) {
    console.log(`🧩 Step: ${step.id}`);
    console.log(`🔧 Tool: ${step.use}`);
    console.log(`📥 Input: ${step.input}`);
    console.log(`📤 Output: ${step.output}`);
    if (step.goal) console.log(`🎯 Goal: ${step.goal}`);
    if (step.constraints) console.log(`🚧 Constraints: ${step.constraints.join(', ')}`);

    // Warn if input was never generated by a previous step
    if (!memory[step.input]) {
      console.warn(`🚨 Input '${step.input}' has not been generated by any prior step.`);
    }

    // Warn if output will overwrite a previous file
    if (memory[step.output]) {
      console.warn(`⚠️ Output '${step.output}' is already in memory. Overwriting.`);
    }

    // Simulate reading input file (this would be used by the agent in a real run)
    try {
      const inputPath = path.resolve(AGENT_DIR, step.input);
      await fs.readFile(inputPath, 'utf-8');
      console.log(`📄 Input file '${step.input}' simulated successfully.`);
    } catch {
      console.warn(`⚠️ Input file '${step.input}' not found. Proceeding with mock.`);
    }

    memory[step.output] = `[simulated output for ${step.id}]`;
    console.log(`🧠 Mock output generated for: ${step.output}\n`);
  }

  // Output mock memory content and confirm simulation is complete
  console.log('📦 Simulated memory contents:');
  Object.entries(memory).forEach(([k, v]) => {
    console.log(`   • ${k} → ${v}`);
  });

  // Output mock memory content and confirm simulation is complete
  console.log('\n✅ Dryrun complete. No files were written or executed.\n');
}
