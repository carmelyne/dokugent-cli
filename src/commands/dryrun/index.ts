import path from 'path';
import fs from 'fs/promises';
import { AGENT_DIR } from '@constants/paths';
import minimist from 'minimist';
import { walkPlan, PlanStep } from '@utils/dryrun/walk-plan';

export async function runDryrunCommand(argv: string[] = []) {
  const args = minimist(argv);
  const summaryOnly = args.summary || false;

  console.log('\n🧪 Dryrun task initialized. No execution will occur.\n');

  const compiledDir = path.join('.dokugent/ops/compiled');
  const agents = await fs.readdir(compiledDir);
  if (agents.length === 0) {
    console.error('❌ No compiled agents found.');
    return;
  }

  const agent = agents[0]; // For now, use the first agent found
  const agentPath = path.join(compiledDir, agent);
  const files = await fs.readdir(agentPath);
  const compiledFiles = files
    .filter(f => /\.compiled\.v\d+\.cert\.json$/.test(f))
    .sort((a, b) => {
      const getVersion = (name: string) => {
        const match = name.match(/\.v(\d+)\.cert\.json$/);
        return match ? parseInt(match[1], 10) : 0;
      };
      return getVersion(b) - getVersion(a); // Descending order
    });
  if (compiledFiles.length === 0) {
    console.error(`❌ No compiled certs found for agent ${agent}.`);
    return;
  }

  const latestCertFile = compiledFiles[0];
  const certPath = path.join(agentPath, latestCertFile);
  const certData = JSON.parse(await fs.readFile(certPath, 'utf-8'));

  const steps = certData?.plan?.steps;
  if (!steps || steps.length === 0) {
    console.error('❌ No steps found in the compiled cert.');
    return;
  }

  if (summaryOnly) {
    console.log(`📋 Summary of planned steps for agent '${agent}':\n`);
    steps.forEach((step: any) => {
      console.log(`• ${step.id} → Tool: ${step.use}`);
    });
    return;
  }

  const memory: Record<string, string> = {};

  for (const step of steps) {
    console.log(`🧩 Step: ${step.id}`);
    console.log(`🔧 Tool: ${step.use}`);
    console.log(`📥 Input: ${step.input}`);
    console.log(`📤 Output: ${step.output}`);
    if (step.goal) console.log(`🎯 Goal: ${step.goal}`);
    if (step.constraints) console.log(`🚧 Constraints: ${step.constraints.join(', ')}`);

    // Warn if input was never generated by a previous step
    if (!memory[step.input]) {
      console.warn(`🚨 Input '${step.input}' has not been generated by any prior step.`);
    }

    // Warn if output will overwrite a previous file
    if (memory[step.output]) {
      console.warn(`⚠️ Output '${step.output}' is already in memory. Overwriting.`);
    }

    // Simulate reading input
    try {
      const inputPath = path.resolve(AGENT_DIR, step.input);
      await fs.readFile(inputPath, 'utf-8');
      console.log(`📄 Input file '${step.input}' simulated successfully.`);
    } catch {
      console.warn(`⚠️ Input file '${step.input}' not found. Proceeding with mock.`);
    }

    memory[step.output] = `[simulated output for ${step.id}]`;
    console.log(`🧠 Mock output generated for: ${step.output}\n`);
  }

  console.log('📦 Simulated memory contents:');
  Object.entries(memory).forEach(([k, v]) => {
    console.log(`   • ${k} → ${v}`);
  });

  console.log('\n✅ Dryrun complete. No files were written or executed.\n');
}
